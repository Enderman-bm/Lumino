# 力度绘制界面优化总结

日期：2025 年 11 月 2 日（第二次修复）

## 问题描述

用户反馈：**绘制时应该保持力度条显示才行**

即使在 Velocity 模式下用铅笔工具绘制力度曲线时，应该：
- ✅ 继续显示力度条背景
- ✅ 同时显示绘制中的曲线预览
- ✅ 不应该隐藏力度条

## 原始问题

在之前的实现中，`DrawVelocityBars` 方法采用了"非此即彼"的逻辑：
- 当 `IsDrawing == true` 时，**完全隐藏力度条**，只显示曲线
- 这导致用户无法参考现有的力度值进行绘制

```csharp
// 修复前 - 不正确的逻辑
if (ViewModel.EventCurveDrawingModule?.IsDrawing == true)
{
    // 显示曲线并直接返回 - 隐藏力度条！
    var curvePoints = ...
    _curveRenderer.DrawEventCurve(...);
    return;  // ← 这里返回，导致力度条不显示
}
```

## 修复方案

### 修改位置

**文件**: `VelocityViewCanvas.cs`
**方法**: `DrawVelocityBars` (行 608-641)

### 修复内容

1. **移除早期返回** - 删除 `IsDrawing` 检查之后的 `return` 语句
2. **移动曲线绘制** - 将曲线绘制移到方法末尾
3. **分层渲染** - 先绘制力度条，再在其上绘制曲线预览

```csharp
// 修复后 - 分层渲染逻辑

// 第 1 层：绘制所有力度条（包括正在绘制的音符）
foreach (var note in visibleNotes)
{
    _velocityRenderer.DrawVelocityBar(context, note, bounds, ...);
}

// 第 2 层：绘制编辑预览（如果在编辑）
if (ViewModel.VelocityEditingModule?.IsEditingVelocity == true)
{
    _velocityRenderer.DrawEditingPreview(...);
}

// 第 3 层：绘制曲线预览（如果正在绘制）
// ★ 关键改动：现在放在最后，在力度条之上
if (ViewModel.EventCurveDrawingModule?.IsDrawing == true)
{
    var curvePoints = ...
    _curveRenderer.DrawEventCurve(context, EventType.Velocity, curvePoints, ...);
}
```

## 渲染层次结构（修复后）

```
┌─────────────────────────────────┐
│  第 3 层：曲线绘制预览          │  ← 最上面，用户可见
├─────────────────────────────────┤
│  第 2 层：编辑预览              │
├─────────────────────────────────┤
│  第 1 层：力度条背景            │  ← 底层基础
├─────────────────────────────────┤
│  网格线                         │
└─────────────────────────────────┘
```

## 预期行为（修复后）

### 场景 1：正常显示力度条
- ✅ 显示所有音符的力度条
- ✅ 网格线显示参考

### 场景 2：用铅笔工具绘制（本次修复的重点）
- ✅ **力度条仍然显示**（不会隐藏）
- ✅ 在力度条上显示绘制的曲线预览
- ✅ 用户可以参考现有力度值进行绘制
- ✅ 完成绘制后，力度值被应用到音符
- ✅ 力度条会更新以反映新值

### 场景 3：编辑力度（使用选择工具）
- ✅ 显示力度条
- ✅ 显示编辑预览（突出正在编辑的音符）

## 修复验证

### 编译验证 ✅

```
编译状态: 成功
错误数: 0
警告数: 106（现有的非相关警告）
编译耗时: 7.56 秒
```

### 代码逻辑验证 ✅

| 检查项 | 结果 | 说明 |
|-------|------|------|
| **渲染顺序** | ✅ | 力度条 → 编辑预览 → 曲线预览 |
| **层次分离** | ✅ | 三层独立渲染，不互相干扰 |
| **性能** | ✅ | 保持原有的性能优化逻辑 |
| **坐标转换** | ✅ | 正确处理 scrollOffset |

## 影响范围

### 直接修改
- `VelocityViewCanvas.cs` 的 `DrawVelocityBars` 方法

### 不受影响
- PitchBend、ControlChange、Tempo 的绘制逻辑（不经过 DrawVelocityBars）
- 数据应用逻辑（已在 OnCurveCompleted 中正确实现）
- 其他事件类型的绘制

## 相关修复历史

### 修复 1：数据保存（前一次）
- **问题**: 绘制完成后数据丢失
- **解决**: 在 OnCurveCompleted 中添加 Velocity case 处理
- **文件**: `VelocityViewCanvas.cs` 行 345-348

### 修复 2：界面显示（本次）
- **问题**: 绘制时力度条隐藏
- **解决**: 分层渲染，保持力度条显示
- **文件**: `VelocityViewCanvas.cs` 行 608-641

## 测试建议

### 手动测试步骤

1. **启动应用**
   - 打开 Lumino
   - 加载 MIDI 文件

2. **进入 Velocity 模式**
   - 选择 Velocity 事件类型
   - 观察力度条显示

3. **使用铅笔工具绘制**
   - 选择铅笔工具（Pencil）
   - 在力度面板上拖动鼠标
   - **关键验证**: 
     - ✅ 力度条应该**继续显示**
     - ✅ 同时看到绘制的曲线预览
     - ✅ 可以参考背景力度条进行绘制

4. **释放并验证**
   - 释放鼠标
   - **验证结果**:
     - ✅ 力度条仍然显示
     - ✅ 力度值已更新
     - ✅ 新的力度值在力度条上反映出来

### 对比验证

| 操作 | 修复前 | 修复后 |
|------|--------|--------|
| 绘制时力度条 | ❌ 隐藏 | ✅ 显示 |
| 绘制时曲线预览 | ✅ 显示 | ✅ 显示 |
| 参考现有值 | ❌ 无法 | ✅ 可以 |
| 完成后数据保存 | ❌ 不保存 | ✅ 保存 |

## 修复完成状态

| 任务 | 状态 | 说明 |
|------|------|------|
| 问题识别 | ✅ | 绘制时隐藏力度条不合理 |
| 原因分析 | ✅ | 过早返回导致隐藏 |
| 代码修复 | ✅ | 移除 return，重新排列渲染顺序 |
| 编译验证 | ✅ | 0 错误 |
| 逻辑审查 | ✅ | 渲染层次正确 |
| 手动测试 | ⏳ | 等待用户验证 |

## 总结

通过重新组织 `DrawVelocityBars` 方法中的渲染逻辑，实现了分层渲染方式：

1. **第 1 层**: 力度条背景（始终显示）
2. **第 2 层**: 编辑预览（编辑时显示）
3. **第 3 层**: 曲线预览（绘制时显示）

这样用户在用铅笔工具绘制力度时，可以同时看到现有的力度条作为参考，同时看到正在绘制的曲线预览，大大改善了用户体验。

修复方案简洁高效，没有增加任何性能负担，同时保持了代码的清晰性和可维护性。
